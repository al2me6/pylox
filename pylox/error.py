from __future__ import annotations

from abc import ABC
from typing import Iterator, Tuple

from pylox.token import Token
from pylox.utilities import eprint


class LoxExit(SystemExit):
    """System exit requested by pylox due to error in input"""


class LoxError(RuntimeError, ABC):
    """Base class for errors generated by the interpreter at runtime due to error in input"""

    def __init__(
            self,
            offset: int,
            message: str,
            *,
            length: int = 1,
            fatal: bool = False
    ) -> None:
        """Base class for errors generated by the interpreter at runtime due to error in input

        :param offset: offset from start of source stream
        :type offset: int
        :param message: error message
        :type message: str
        :param length: length of error marker, defaults to 1
        :type length: int, optional
        :param fatal: whether immediate exit is necessary, defaults to False
        :type fatal: bool, optional
        """
        super().__init__(f"{message} at offset {offset}")
        self.message = message
        self.offset = offset
        self.length = length
        self.fatal = fatal

    @classmethod
    def at_token(cls, token: Token, message: str, *, fatal: bool = False) -> LoxError:
        length = len(token.lexeme) if token.lexeme else 1
        return cls(token.offset, message, length=length, fatal=fatal)


class LoxSyntaxError(LoxError):
    """Syntax error produced by pylox"""


class LoxRuntimeError(LoxError):
    """Runtime error produced by pylox"""


class LoxErrorHandler:
    LINE_NUMBER_SEPARATOR = " | "
    ERROR_MARKER = "^"

    def __init__(self) -> None:
        self.error_state = False
        self._source = ""

    def clear_errors(self) -> None:
        self.error_state = False

    def set_source(self, source) -> None:
        self._source = source
        self.clear_errors()

    def err(self, error: LoxError) -> None:
        """Report an error

        :param error: error object containing error details
        :type error: LoxError
        """
        self.error_state = True
        line_number, line, line_offset = self._locate_in_line(error.offset)
        self._report(
            type(error).__name__,
            error.message,
            line,
            line_number,
            line_offset,
            error.length
        )
        if error.fatal:  # force immediate exit
            self.checkpoint()

    def checkpoint(self) -> None:
        """Exit if an error has occurred before the checkpoint."""
        if self.error_state:
            raise LoxExit(1)

    def _source_as_lines(self) -> Iterator[Tuple[int, int, str]]:
        """Split the source string into lines while tracking offset and line number

        :yield: end offset of line, number of line (1-indexed), content of line
        :rtype: Tuple[int, int, str]
        """
        line_end_offset = 0
        for line_number, line in enumerate(self._source.split("\n"), start=1):
            line_end_offset += len(line)
            if line_number > 1:  # account for character lost to splitting
                line_end_offset += 1
            yield line_end_offset, line_number, line

    def _locate_in_line(self, offset: int) -> Tuple[int, str, int]:
        """Calculate the position of an offset relative to a line

        :param offset: target offsest
        :type offset: int
        :return: line number on which `offset` is found, content of line, position of `offset` within line
        :rtype: Tuple[int, str, int]
        """
        lines = self._source_as_lines()
        line_start_offset = 0
        line_end_offset = 0
        line_number = 1
        line = ""
        while line_end_offset < offset:
            line_start_offset = line_end_offset
            line_end_offset, line_number, line = next(lines)
        offset_from_line_start = offset - line_start_offset
        return line_number, line, offset_from_line_start

    def _report(
            self,
            error_name: str,
            error_message: str,
            line: str,
            line_number: int,
            line_offset: int,
            length: int
    ) -> None:
        eprint(f"\t{line_number}{self.LINE_NUMBER_SEPARATOR}{line}")
        arrow_spacer = "\t" + " " * (len(str(line_number) + self.LINE_NUMBER_SEPARATOR) + (line_offset - length))
        eprint(arrow_spacer + self.ERROR_MARKER * length)
        eprint(f"{error_name}: Line {line_number}: {error_message}")
